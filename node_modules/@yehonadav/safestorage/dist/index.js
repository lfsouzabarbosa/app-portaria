Object.defineProperty(exports, '__esModule', { value: true });

var storageFactory = require('storage-factory');
var safestringify = require('@yehonadav/safestringify');

var getStorageItems = function (storage) {
    var result = {};
    for (var i = 0, len = storage.length; i < len; ++i) {
        try {
            var k = storage.key(i);
            if (k === null)
                continue;
            var value = storage.getItem(k);
            result[k] = value ? JSON.parse(value) : value;
        }
        catch (e) {
            console.error({ getStorageItemsError: e });
        }
    }
    return result;
};
var setStorageItem = function (storage, uuid, state) { storage.setItem(uuid, safestringify.stringify({ state: state })); };
var getStorageItem = function (storage, uuid) {
    var value = storage.getItem(uuid);
    if (value === null)
        throw Error("getStorageItemValueError: storage.getItem('" + uuid + "') did not return a value");
    return JSON.parse(value).state;
};
var tryToGetStorageItem = function (storage, uuid) {
    try {
        return { value: getStorageItem(storage, uuid) };
    }
    catch (error) {
        return { error: error };
    }
};
var delStorageItem = function (storage, uuid) {
    // eslint-disable-next-line no-empty
    try {
        storage.removeItem(uuid);
    }
    catch (e) { }
};
var StorageHandler = /** @class */ (function () {
    function StorageHandler(getStorage) {
        this.storage = storageFactory.storageFactory(getStorage);
        this.clear = this.storage.clear;
        this._debug = false;
        this._setItem = this.storage.setItem;
        this._clear = this.storage.clear;
        this._removeItem = this.storage.removeItem;
    }
    StorageHandler.prototype.setDebug = function (debug) {
        var _this = this;
        this._debug = debug;
        if (debug) {
            this.storage.setItem = function (key, value) {
                console.log({ "storage.setItem": { key: key, value: value } });
                _this._setItem(key, value);
            };
            this.storage.clear = function () {
                console.log("storage.clear");
                _this._clear();
            };
            this.storage.removeItem = function (key) {
                console.log({ "storage.removeItem": { key: key } });
                _this._removeItem(key);
            };
        }
        else {
            if (debug) {
                this.storage.setItem = this._setItem;
                this.storage.clear = this._clear;
                this.storage.removeItem = this._removeItem;
            }
        }
    };
    StorageHandler.prototype.getDebug = function () {
        return this._debug;
    };
    StorageHandler.prototype.getItems = function () {
        return getStorageItems(this.storage);
    };
    StorageHandler.prototype.setItem = function (uuid, state) {
        setStorageItem(this.storage, uuid, state);
    };
    StorageHandler.prototype.getItem = function (uuid) {
        return getStorageItem(this.storage, uuid);
    };
    StorageHandler.prototype.tryToGetItem = function (uuid) {
        return tryToGetStorageItem(this.storage, uuid);
    };
    StorageHandler.prototype.delItem = function (uuid) {
        delStorageItem(this.storage, uuid);
    };
    return StorageHandler;
}());
var persistLocal = new StorageHandler(function () { return localStorage; });
var persistSession = new StorageHandler(function () { return sessionStorage; });
var local = persistLocal.storage;
var session = persistSession.storage;

var getStorageCall = function () { return local; };
var getSessionCall = function () { return session; };

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var excludedLocalStorageItemKeys = [];
var excludeLocalStorageItem = function (key) {
    excludedLocalStorageItemKeys.push(key);
};
var getExcludedLocalStorageItems = function () {
    var items = {};
    excludedLocalStorageItemKeys.forEach(function (key) {
        try {
            var item = local.getItem(key);
            if (typeof item === "string")
                items[key] = item;
        }
        catch (e) {
            console.error("getExcludeLocalStorageItems failed to get " + key, e);
        }
    });
    return items;
};
var setExcludedLocalStorageItemsAfterClear = function (items) {
    Object.keys(items).forEach(function (key) {
        local.setItem(key, items[key]);
    });
};
var clearCachedData = function () { return __awaiter(void 0, void 0, void 0, function () {
    var excludedLocalStorageItems, cacheNames, e_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                excludedLocalStorageItems = getExcludedLocalStorageItems();
                console.log({
                    clearCachedData: {
                        getExcludedLocalStorageItems: {
                            type: 'info',
                            message: "get excluded items before clearing data",
                            data: excludedLocalStorageItems,
                        }
                    }
                });
                session.clear();
                local.clear();
                console.log({
                    clearCachedData: {
                        type: 'info',
                        message: "cleared session & local storage",
                        data: {
                            session: getStorageItems(session),
                            local: getStorageItems(local),
                        },
                    }
                });
                // early re-set excluded items before clearing data finish, to handle sudden abruption
                setExcludedLocalStorageItemsAfterClear(excludedLocalStorageItems);
                if (!('serviceWorker' in navigator)) return [3 /*break*/, 4];
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4 /*yield*/, caches.keys()];
            case 2:
                cacheNames = _a.sent();
                cacheNames.forEach(function (cacheName) {
                    caches.delete(cacheName);
                });
                console.log({
                    clearCachedData: {
                        type: 'info',
                        message: "cleared caches",
                    }
                });
                return [3 /*break*/, 4];
            case 3:
                e_1 = _a.sent();
                console.error({
                    clearCachedData: {
                        type: 'info',
                        message: "clearCachedData failed to delete cacheNames: " + e_1,
                    }
                });
                return [3 /*break*/, 4];
            case 4:
                console.log({
                    clearCachedData: {
                        type: 'info',
                        message: "all cached data has been removed",
                    }
                });
                // re-set excluded items after clearing data
                setExcludedLocalStorageItemsAfterClear(excludedLocalStorageItems);
                console.log({
                    clearCachedData: {
                        setExcludedLocalStorageItemsAfterClear: {
                            type: 'info',
                            message: "re-set excluded items after clearing data success",
                            data: excludedLocalStorageItems,
                        }
                    }
                });
                return [2 /*return*/];
        }
    });
}); };
var clearDataService = {
    excludeLocalStorageItem: excludeLocalStorageItem,
    clearCachedData: clearCachedData,
};

exports.StorageHandler = StorageHandler;
exports.clearCachedData = clearCachedData;
exports.clearDataService = clearDataService;
exports.delStorageItem = delStorageItem;
exports.excludeLocalStorageItem = excludeLocalStorageItem;
exports.excludedLocalStorageItemKeys = excludedLocalStorageItemKeys;
exports.getExcludedLocalStorageItems = getExcludedLocalStorageItems;
exports.getSessionCall = getSessionCall;
exports.getStorageCall = getStorageCall;
exports.getStorageItem = getStorageItem;
exports.getStorageItems = getStorageItems;
exports.local = local;
exports.persistLocal = persistLocal;
exports.persistSession = persistSession;
exports.session = session;
exports.setExcludedLocalStorageItemsAfterClear = setExcludedLocalStorageItemsAfterClear;
exports.setStorageItem = setStorageItem;
exports.tryToGetStorageItem = tryToGetStorageItem;
//# sourceMappingURL=index.js.map
